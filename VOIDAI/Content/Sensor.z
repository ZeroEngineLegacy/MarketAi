/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2016                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Arend Danielek                                                                          */
/* Class: Sensor                                                                                            */
/* Brief: Detects objects with range limited raycasts in front of the object Sensor is attached to.         */
/************************************************************************************************************/

// Contain pertinate object sensed the distances to those objects
// and the angle changed as a result of sensing those objects
class SensorEvent : ZilchEvent
{
    sends SensorEvent : SensorEvent;
    
    var Objects : Array[Cog] = new Array[Cog]();
    var Distances : Array[Real] = new Array[Real]();
    var ContactPoints : Array[Real3] = new Array[Real3]();
    var ContactNormals : Array[Real3] = new Array[Real3]();
}

enum SensorMode
{
    PrimaryAndSideSensors,
    SideSensors,
    RandomPrimarySensor
}

class SensorRay
{
    var Direction : Real3 = Real3(0.0, 0.0, 0.0);
    var Distance : Real = 0.0;
}

class Sensor : ZilchComponent
{
    [Dependency]
    var Transform : Transform;
    
    // This Component uses the orientation component
    [Dependency]
    var Orientation : Orientation = null;
    
    // Is the component active
    [Property]
    var Active : Boolean = true;
    
    // Do we draw the debug information?
    [Property]
    var EnableDebugDraw : Boolean = false;
    
    // Do we want to send events containing sensor data to this object
    [Property]
    var SensorEventTarget : CogPath = null;
    
    // What kind of mode are we in with the sensors
    [Property]
    var SensorMode : SensorMode = SensorMode.PrimaryAndSideSensors;
    
    // The angle of the side sensors
    [Property]
    var SideSensorAngle : Real = 45.0;
    
    // The max distance of the side sensors
    [Property]
    var SideSensorDistance : Real = 2.0;
    
    // The max distance of the primary sensor
    [Property]
    var PrimarySensorDistance : Real = 6.0;
    
    // The maximum angle used for random primary sesors
    [Property]
    var PrimarySensorMaxAngle : Real = 30.0;
    
    // The offset in local space of the ray casting
    [Property]
    var LocalOffset : Real3 = Real3(0.0, 0.0, 0.0);
    
    [Property]
    var SparseUpdate : Boolean = true;
    
    [Property]
    var SparseUpdateMaxTimeout : Integer = 5;
    
    var UpdateTimeout : Integer = 0;
    
    var Random : Random = Random();
    
    var SideSensorAngleRad : Real
    {
        get { return Math.ToRadians(this.SideSensorAngle); }
    }
    
    var PrimarySensorMaxAngleRad : Real
    {
        get { return Math.ToRadians(this.PrimarySensorMaxAngle); }
    }
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    }
    
    function OnLogicUpdate(updateEvent : UpdateEvent)
    {
        if (this.UpdateTimeout > 0)
        {
            --this.UpdateTimeout;
            return;
        }
        
        var sensors = new Array[SensorRay]();
        var event : SensorEvent = new SensorEvent();
        var position = this.Transform.TransformPoint(this.LocalOffset);
        
        // Construct the array of sensors
        this.SetupSensors(sensors, position);
        
        // Raycast using the sensors we've constructed
        this.CastRays(sensors, position, event);
        
        // Dispatch the results of those raycasts
        this.DispatchEvent(event);
        
        if (this.SparseUpdate)
        {
            this.UpdateTimeout += this.Random.RangeInclusiveMax(
                0, this.SparseUpdateMaxTimeout
            );
        }
    }
    
    // Construct our SensorRay array based on our SensorMode
    function SetupSensors(sensors : Array[SensorRay], position : Real3)
    {
        // Create the side sensors...
        if (this.SensorMode == SensorMode.PrimaryAndSideSensors ||
            this.SensorMode == SensorMode.SideSensors)
        {
            // Set the direction and distance of the left sensor
            var leftSensor = new SensorRay();
            
            leftSensor.Distance = this.SideSensorDistance;
            leftSensor.Direction = Math.RotateVector(
                this.Orientation.WorldForward, this.Orientation.WorldUp,
                this.SideSensorAngleRad * 0.5
            );
            
            sensors.Add(leftSensor);
            
            // Set the direction and distance of the right sensor
            var rightSensor = new SensorRay();
            
            rightSensor.Distance = this.SideSensorDistance;
            rightSensor.Direction = Math.RotateVector(
                this.Orientation.WorldForward, this.Orientation.WorldUp,
                -this.SideSensorAngleRad * 0.5
            );
            
            sensors.Add(rightSensor);
        }
        
        // Create the primary sensor...
        if (this.SensorMode == SensorMode.PrimaryAndSideSensors)
        {
            // Setup the primary sensor's start, direction, and distance
            var primarySensor = new SensorRay();
            
            primarySensor.Distance = this.PrimarySensorDistance;
            primarySensor.Direction = this.Orientation.WorldForward;
            
            sensors.Add(primarySensor);
        }
        else if (this.SensorMode == SensorMode.RandomPrimarySensor)
        {
            // Get the primary angle from a random function
            var primaryAngle = this.Random.Range(-this.PrimarySensorMaxAngleRad * 0.5, this.PrimarySensorMaxAngleRad * 0.5);
            var primaryRotation = Math.ToQuaternion(this.Orientation.WorldUp, primaryAngle);
            
            var primarySensor = new SensorRay();
            
            primarySensor.Distance = this.PrimarySensorDistance;
            primarySensor.Direction = Math.Transform(
                this.Orientation.WorldForward, primaryRotation
            );
            
            sensors.Add(primarySensor);
        }
        
        // If debug draw is enabled...
        if (this.EnableDebugDraw)
        {
            // Loop through all the sensors
            foreach (var sensor in sensors)
            {
                // Draw the primary sensor...
                this.DebugDrawLine(
                    position, position + sensor.Direction * sensor.Distance, 
                    0.3, Real4(0.0, 0.0, 1.0, 1.0)
                );
            }
        }
    }
    
    function CastRays(sensors : Array[SensorRay], position : Real3, event : SensorEvent)
    {
        // If we have a physics space, do the ray casts
        var physics = this.Space.PhysicsSpace;
        
        if (physics == null)
        {
            return;
        }
        
        // Loop through all the sensors
        foreach (var sensor in sensors)
        {
            // Do the ray cast
            var castResultsMax = 3;
            
            var ray = local Ray();
            ray.Start = position;
            ray.Direction = sensor.Direction;
            
            var results = physics.CastRayResults(ray, castResultsMax);
            
            // Loop through all the results
            foreach (var result in results)
            {
                // Get the hit distance
                var distance = result.Distance;
                
                // As long as the object hit wasn't us and it's within the maximum distance...
                if (result.ObjectHit != this.Owner && distance < sensor.Distance)
                {
                    // Store the hit object and the distance to it in the sensorEvent
                    event.Objects.Add(result.ObjectHit);
                    event.Distances.Add(distance);
                    event.ContactPoints.Add(result.WorldPosition);
                    event.ContactNormals.Add(result.Normal);
                    
                    // If debug draw is on, draw the intersection point and the normal
                    if (this.EnableDebugDraw)
                    {
                        this.DebugDrawSphere(
                            0.5, result.WorldPosition, Real4(0.0, 1.0, 0.0, 1.0)
                        );
                        
                        this.DebugDrawLine(
                            result.WorldPosition, result.WorldPosition + result.Normal, 
                            0.2, Real4(1.0, 0.0, 0.0, 1.0)
                        );
                    }
                    
                    break;
                }
            }
        }
    }
    
    function DispatchEvent(event : SensorEvent)
    {
        // Send out the sendor event so other components can use the sensor data
        if (event.Objects.Count <= 0)
        {
            return;
        }
        
        // If there is no target defined dispatch the event on this.Owner
        if(this.SensorEventTarget.Cog != null)
        {
            this.SensorEventTarget.Cog.DispatchEvent(Events.SensorEvent, event);
        }
        else
        {
            this.Owner.DispatchEvent(Events.SensorEvent, event);
        }
    }
    
    function DebugDrawSphere(radius : Real, position : Real3, color : Real4)
    {
        var sphere = new DebugSphere();
        
        sphere.Position = position;
        sphere.Radius = radius;
        sphere.Color = color;
        
        DebugDraw.Add(sphere);
    }
    
    function DebugDrawLine(start : Real3, end : Real3, size : Real, color : Real4)
    {
        var line = new DebugLine();
        
        line.Start = start;
        line.End = end;
        line.HeadSize = size;
        line.Color = color;
        
        DebugDraw.Add(line);
    }
}
