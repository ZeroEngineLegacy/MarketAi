/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2016                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Jordan Ellis                                                                            */
/* Class: Pursue                                                                                            */
/* Brief: This component will cause the object to pursue a target object by                                 */
/* using the target obect's velocity to attampt to estimate a future position                               */
/************************************************************************************************************/

class Pursue : SteeringComponent
{
  [Dependency]
  var Transform : Transform = null;
  
  // Pursue requires an Orientation & OrientationHelper component
  [Dependency]
  var Orientation : Orientation = null;
  
  // Target object to be pursue towards
  [Property]
  var Target : CogPath = null;
  
  // Range from the object in which it is valid to pursue the target object
  // If the range is 0 the target object will always be pursued
  [Property]
  var PursueRange : Real = 0.0;
  
  // Magnitude of the velocity vector to be used when prediction target motion
  // If the range is 0.0 Dt will be used to estimate the position of the object in the next frame
  [Property]
  var PredictionRange : Real = 0.0;
  
  // Distance from the goal we're trying to seek to
  [Property]
  var GoalDistance : Real = 0.0;
  
  var NoPursueRange : Boolean
  {
    get { return Math.ApproximatelyEqual(this.PursueRange, 0.0, 0.001); }
  }
  
  var TargetTranslation : Real3
  {
    get { return this.Target.Cog.Transform.WorldTranslation; }
  }
  
  var TargetPrevTranslation : Real3;
  
  [Override]
  function SteeringInitialize(init : CogInitializer)
  {
    this.TargetPrevTranslation = this.TargetTranslation;
  }
  
  [Override]
  function SteeringUpdate(event : UpdateEvent)
  {
    // If this component is not active do nothing
    if (!this.Active || !this.SteeringAccumulator.Active)
    {
      return;
    }
    
    // Get the target's distance from our position, and determine how much we're predicting by
    var targDir = this.TargetTranslation - this.Transform.WorldTranslation;
    var targDis = Math.LengthSq(targDir);
    var prediction = Math.Max(this.PredictionRange, event.Dt);
    
    // If we're nearing in on the obect (less than prediction length)
    // reduce what we're predicting by, closing in on 0 prediction (at target)
    if (targDis < prediction * prediction)
    {
      prediction -= (prediction - Math.Sqrt(targDis));
    }
    
    // Estimate the target object's predicted future position
    var targVel = Math.Normalize(this.TargetTranslation - this.TargetPrevTranslation);
    var predictedPos = this.TargetTranslation + (targVel * prediction);
    var predictedDir = predictedPos - this.Transform.WorldTranslation;
    var predictedDis = Math.Length(predictedDir);
    
    predictedDir /= predictedDis;
    
    if (this.NoPursueRange || predictedDis <= this.PursueRange)
    {
      // Check if the target object is with in the range to seek it
      if (this.NoPursueRange || predictedDis > this.GoalDistance)
      {
        // Apply a force to move the object towards the target object's position
        this.AddLookDirection(predictedDir);
        this.AddLocalMovement(this.Orientation.LocalForward);
      }
      else
      {
        // Bring the object to a smooth stop, based on it's linear distance from the target
        var ratio = predictedDis / this.GoalDistance;
        
        this.AddLookDirection(this.TargetTranslation);
        this.SteeringAccumulator.AddLocalMovement(
          this.Orientation.LocalForward, this.MovementWeight * ratio * ratio
        );
      }
    }
    
    // Store this for next update
    this.TargetPrevTranslation = this.TargetTranslation;
  }
}
