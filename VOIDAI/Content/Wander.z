/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2016                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Jordan Ellis                                                                            */
/* Class: Wander                                                                                            */
/* Brief: This steering behavior maintains the "wandering direction" which is calculated by finding a       */
/*        vector from the object to a point on a circle offset from the object in the direction of its      */
/*        velocity. At each time step a random offset is added to the wander direction. The modified wander */
/*        direction is constrained to lie on a circle.                                                      */
/************************************************************************************************************/

class Wander : SteeringComponent
{
    [Dependency]
    var Transform : Transform = null;
    
    [Dependency]
    var RigidBody : RigidBody = null;
    
    [Dependency]
    var Orientation : Orientation = null;
    
    // The radius of the circle which the target point is constrained to
    [Property]
    var CircleRadius : Real = 5;
    
    // The maximum angle of displacement on the circle
    [Property]
    var WanderAngle : Real = 45.0;
    
    [Property]
    var SparseUpdate : Boolean = true;
    
    [Property]
    var SparseUpdateMaxTimeout : Integer = 5;
    
    var UpdateTimeout : Integer = 0;
    
    var RandomGenerator : Random = new Random();
    
    var Result : Real3 = Real3.Zero;
    
    [Override]
    function SteeringInitialize(init : CogInitializer)
    {
        var seed = this.Transform.Translation.X +
                   this.Transform.Translation.Y +
                   this.Transform.Translation.Z +
                   this.Space.TimeSpace.RealTimePassed;
        
        // Seed the random number generator
        this.RandomGenerator.Seed = seed as Integer;
    }

    [Override]
    function SteeringUpdate(event : UpdateEvent)
    {
        // If the component is not active do nothing
        if(!this.Active || !this.SteeringAccumulator.Active)
        {
            return;
        }
        
        if (this.UpdateTimeout > 0)
        {
            --this.UpdateTimeout;
            this.AddImpulse(this.Result);
            return;
        }
        
        // Get the rigidbody's current velocity
        var velocity = this.RigidBody.Velocity;
        
        if (velocity == Real3.Zero)
        {
            velocity = this.Orientation.WorldForward;
        }
        
        // Normalize, and rotate that vector by a random angle
        var angle = this.RandomGenerator.Range(-this.WanderAngle, this.WanderAngle);
        
        // Get the axis we're going to rotate around
        var axis = Real3.Zero;
        
        if (velocity == this.Orientation.WorldRight)
        {
            axis = Math.Cross(velocity, this.Orientation.WorldForward);
        }
        else
        {
            axis = Math.Cross(this.Orientation.WorldRight, velocity);
        }
        
        var displacement = Math.Normalize(velocity) * this.CircleRadius;
        
        displacement = Math.RotateVector(displacement, axis, Math.ToRadians(angle));
        
        // Add the velocity, and the rotated vector
        this.Result = Math.Normalize(velocity + displacement);
        
        // Add the normalized addition of those two vectors
        this.AddImpulse(this.Result);
        
        if (this.SparseUpdate)
        {
            this.UpdateTimeout += this.RandomGenerator.RangeInclusiveMax(
                0, this.SparseUpdateMaxTimeout
            );
        }
    }
}
