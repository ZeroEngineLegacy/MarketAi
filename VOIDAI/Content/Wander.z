/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2016                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Jordan Ellis                                                                            */
/* Class: Wander                                                                                            */
/* Brief: This steering behavior maintains the "wandering direction" which is calculated by finding a       */
/*        vector from the object to a point on a circle offset from the object in the direction of its      */
/*        velocity. At each time step a random offset is added to the wander direction. The modified wander */
/*        direction is constrained to lie on a circle.                                                      */
/************************************************************************************************************/

class Wander : SteeringComponent
{
    [Dependency]
    var Transform : Transform = null;
    
    [Dependency]
    var Orientation : Orientation = null;
    
    // Should we wander in 2D or 3D
    [Property]
    var Mode : Mode2DStates = Mode2DStates.Mode2D;
    
    // The radius of the circle/sphere which the target point is constrained to
    [Property]
    var Radius : Real = 5;
    
    // The maximum angle of displacement on the circle/sphere
    [Property]
    var WanderAngle : Real = 45.0;
    
    // The offset distance the circle/sphere is from the object
    [Property]
    var WanderOffset : Real = 1.0;
    
    [Property]
    var Movement : Boolean = true;
    
    [Property]
    var SparseUpdate : Boolean = true;
    
    [Property]
    var SparseUpdateMaxTimeout : Integer = 5;
    
    var UpdateTimeout : Integer = 0;
    
    var RandomGenerator : Random = new Random();
    
    var Result : Real3 = Real3.Zero;
    
    var WanderAngleRad : Real
    {
        get { return Math.ToRadians(this.WanderAngle); }
    }
    
    [Override]
    function SteeringInitialize(init : CogInitializer)
    {
        var seed = this.Transform.Translation.X +
                   this.Transform.Translation.Y +
                   this.Transform.Translation.Z +
                   this.Space.TimeSpace.RealTimePassed;
        
        // Seed the random number generator
        this.RandomGenerator.Seed = seed as Integer;
    }

    [Override]
    function SteeringUpdate(event : UpdateEvent)
    {
        // If the component is not active do nothing
        if(!this.Active || !this.SteeringAccumulator.Active)
        {
            return;
        }
        
        // If we're currently timed out, just apply the same direction
        if (this.UpdateTimeout > 0)
        {
            --this.UpdateTimeout;
            this.AddLookDirection(this.Result);
            
            if (this.Movement)
            {
                this.AddLocalMovement(this.Orientation.LocalForward);
            }
            
            return;
        }
        
        // Determine whether we're using a circle or a sphere for our wander direction
        var mode2D = true;
        
        if (this.Mode == Mode2DStates.Mode3D)
        {
            mode2D = false;
        }
        else if (this.Mode == Mode2DStates.InheritFromSpace)
        {
            mode2D = this.Space.PhysicsSpace.Mode2D;
        }
        
        if (mode2D)
        {
            this.WanderCircle();
        }
        else
        {
            this.WanderSphere();
        }
        
        // Apply the calculated resulting direction
        this.AddLookDirection(this.Result);
        
        if (this.Movement)
        {
            this.AddLocalMovement(this.Orientation.LocalForward);
        }
        
        if (this.SparseUpdate)
        {
            this.UpdateTimeout += this.RandomGenerator.RangeInclusiveMax(
                0, this.SparseUpdateMaxTimeout
            );
        }
    }
    
    function WanderCircle()
    {
        // Calculate the rotation angle
        var angle = this.RandomGenerator.Range(-this.WanderAngleRad, this.WanderAngleRad);
        
        // Calculate the rotated vector
        var rotation = Math.AxisAngle(this.Orientation.WorldUp, angle);
        var direction = Math.Transform(this.Orientation.WorldForward, rotation);
        
        // Calculate the normalized new direction vector
        this.Result = this.Orientation.WorldForward * this.WanderOffset + 
                      direction * this.Radius;
        this.Result = Math.Normalize(this.Result);
    }
    
    function WanderSphere()
    {
        // Calculate the rotation angle
        var angle = this.RandomGenerator.Range(-this.WanderAngleRad, this.WanderAngleRad);
        
        // Generate a random point on the sphere within a cone
        var point = this.RandomGenerator.UnitReal3() * Math.Sin(angle);
        point = Real3(point.X, point.Y, Math.Cos(angle));
        
        var direction = Math.Transform(point, this.Orientation.WorldRotation);
        
        this.Result = this.Orientation.WorldForward * this.WanderOffset +
                      direction * this.Radius;
        this.Result = Math.Normalize(this.Result);
    }
}
