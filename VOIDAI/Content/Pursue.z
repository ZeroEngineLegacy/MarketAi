/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2016                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Arend Danielek                                                                          */
/* Class: Pursue                                                                                            */
/* Brief: This component will cause the object to pursue a target object by                                 */
/* using the target obect's velocity to attampt to estimate a future position                               */
/************************************************************************************************************/

class Pursue : SteeringComponent
{
    [Dependency]
    var Transform : Transform = null;
    
    // Seek requires an Orientation & OrientationHelper component
    [Dependency]
    var Orientation : Orientation = null;
    
    [Dependency]
    var OrientationHelper : OrientationHelper = null;
    
    // Target object to be pursue towards
    [Property]
    var Target : CogPath = null;
    
    // Range from the object in which it is valid to pursue the target object
    // If the range is 0 the target object will always be pursued
    [Property]
    var PursueRange : Real = 0.0;
    
    // Magnitude of the velocity vector to be used when prediction target motion
    // If the range is 0.0 Dt will be used to estimate the position of the object in the next frame
    [Property]
    var PredictionRange : Real = 0.0;
    
    // Distance from the goal we're trying to seek to
    [Property]
    var GoalDistance : Real = 0.0;
    
    var NoPursueRange : Boolean
    {
        get { return Math.ApproximatelyEqual(this.PursueRange, 0.0, 0.001); }
    }
    
    var TargetTranslation : Real3
    {
        get { return this.Target.Cog.Transform.Translation; }
    }
    
    var TargetPrevTranslation : Real3;
    
    [Virtual]
    function SteeringInitialize(init : CogInitializer)
    {
        this.TargetPrevTranslation = this.TargetTranslation;
    }
    
    [Override]
    function SteeringUpdate(event : UpdateEvent)
    {
        // If this component is not active do nothing
        if (!this.Active || !this.SteeringAccumulator.Active)
        {
            return;
        }
        
        // Get the target object's normalized velocity for the prediction estimation
        var targVelDir = this.TargetTranslation - this.TargetPrevTranslation;
        this.TargetPrevTranslation = this.TargetTranslation;
        
        // If PredictionRange is 0.0 then use Dt to predict target object motion
        var predictionMagnitude = this.PredictionRange;
        if (this.PredictionRange == 0.0)
        {
            predictionMagnitude = event.Dt;
        }
        else
        {
            targVelDir = Math.Normalize(targVelDir);
        }
        
        // Estimate the target object's predicted future position
        var targPos = this.TargetTranslation + (targVelDir * predictionMagnitude);
        
        // Calculate a vector to the target object's predicted position
        var targDir = targPos - this.Transform.Translation;
        var targDis = Math.Length(targDir);
        
        // Normalize the vector to the target object so it does not affect movement speed
        targDir /= targDis;
        
        if (!this.NoPursueRange && targDis > this.PursueRange)
        {
            return;
        }
        
        // Check if the target object is with in the range to seek it
        if (this.NoPursueRange || targDis > this.GoalDistance)
        {
            // Apply a force to move the object towards the target object's position
            this.AddImpulse(targDir);
        }
        else
        {
            // Bring the object to a smooth stop, based on it's linear distance from the target
            var ratio = targDis / this.GoalDistance;
            
            this.SteeringAccumulator.AddImpulse(targDir, this.Weight * ratio);
        }
    }
}
