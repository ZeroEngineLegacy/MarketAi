/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2016                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Arend Danielek                                                                          */
/* Class: Avoidance                                                                                        */
/* Brief: TODODODODODODODOD                   */
/************************************************************************************************************/

class Avoidance : SteeringComponent
{
    [Dependency]
    var Transform : Transform = null;
    
    // This component reuires a Sensor
    [Dependency]
    var Sensor : Sensor = null;
    
    [Dependency]
    var Orientation : Orientation = null;
    
    // This angle + forward vector define the cone we use in our contact point processing
    [Property]
    var ConeAngle : Real
    {
        get { return this.ConeAngleVal; }
        set { this.ConeAngleVal = Math.Clamp(value, 0.0, 180.0); }
    }
    
    [Property]
    var ConeDistance : Real = 5.0;
    
    /*[Property]
    var FalloffDistance : Real = 10.0;
    
    [Property]
    var FalloffCurve : SampleCurve = SampleCurve.DefaultCurve;*/
    
    var ConeAngleVal : Real = 45.0;
    
    var ConeAngleRad : Real
    {
        get { return Math.ToRadians(this.ConeAngle); }
    }
    
    // The impulse we apply to the steering when we update
    var Impulse : Real3;
    
    [Override]
    function SteeringInitialize(init : CogInitializer)
    {
        Zero.Connect(this.Owner, Events.SensorEvent, this.OnSensorEvent);
    }
    
    [Override]
    function SteeringUpdate(event : UpdateEvent)
    {
        this.Impulse = Math.Normalize(this.Impulse);
        
        this.AddImpulse(this.Impulse);
        
        this.Impulse = Real3.Zero;
    }
    
    // Responds to the sensor object detecting obstacles in the object's estimated projected path
    function OnSensorEvent(event : SensorEvent)
    {
        for (var i = 0; i < event.Objects.Count; ++i)
        {
            var dist = event.Distances[i];
            var pos = event.ContactPoints[i];
            var norm = event.ContactNormals[i];
            var dir = Math.Normalize(pos - this.Transform.Translation);
            var angle = Math.AngleBetween(this.Orientation.WorldForward, dir);
            
            // Ignore all contacts outside of our cone
            if (Math.Abs(angle) > this.ConeAngleRad || dist > this.ConeDistance)
            {
                continue;
            }
            
            // Get the angle between the -normal and the forward
            var normAngle = Math.AngleBetween(this.Orientation.WorldForward, -norm);
            
            if (normAngle > 0)
            {
                angle = this.ConeAngleRad - normAngle;
            }
            else
            {
                angle = -this.ConeAngleRad - normAngle;
            }
            
            // Rotate the forward vector, about the up vector, by the given angle
            dir = Math.RotateVector(this.Orientation.WorldForward, this.Orientation.WorldUp, angle);
            
            // Accumulate the results
            this.Impulse += dir;
        }
    }
}
