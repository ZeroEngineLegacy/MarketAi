/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2016                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Jordan Ellis                                                                            */
/* Class: Avoidance                                                                                         */
/* Brief: TODODODODODODODOD                                                                                 */
/************************************************************************************************************/

class Avoidance : SteeringComponent
{
    [Dependency]
    var Transform : Transform = null;
    
    [Dependency]
    var Orientation : Orientation = null;
    
    // Allow yaw rotation (about the orientation's up vector)
    [Property]
    var YawRotation : Boolean = true;
    
    // Allow pitch rotation (about the orientation's right vector)
    [Property]
    var PitchRotation : Boolean = true;
    
    // The avoidance cone's distance
    [Property]
    var ConeDistance : Real = 5.0;
    
    // The avoidance cone's angle (degrees)
    [Property]
    var ConeAngle : Real = 45.0;
    
    // Our cached sensor results
    var SensorResults : Array[SensorResult] = null;
    
    // Keep track of our last rotation
    var LastYawRotation : Real = 0.0;
    
    var ConeAngleRad : Real
    {
        get
        {
            return Math.ToRadians(this.ConeAngle);
        }
    }
    
    var DebugDrawEnabled : Boolean
    {
        get
        {
            return this.SteeringAccumulator.DebugDrawEnabled;
        }
    }
    
    [Override]
    function SteeringInitialize(init : CogInitializer)
    {
        // Connect to this object's sensor results
        Zero.Connect(this.Owner, Events.SensorEvent, this.OnSensorEvent);
    }
    
    [Override]
    function SteeringUpdate(event : UpdateEvent)
    {
        var worldForward = this.Orientation.WorldForward;
        var rotated = false;
        
        if (this.DebugDrawEnabled)
        {
            // Draw the avoidance cone
            this.DebugDrawCone(worldForward);
            
            // Draw the contacts
            this.DebugDrawContacts();
        }
        
        // Solve for Yaw
        if (this.YawRotation && this.SensorResults != null)
        {
            var worldRight = this.Orientation.WorldRight;
            var worldUp = this.Orientation.WorldUp;
            var posAngleChange = 0.0;
            var negAngleChange = 0.0;
            var posClosestDistance = this.ConeDistance;
            var negClosestDistance = this.ConeDistance;
            var yawAngleChange = 0.0;
            
            // Iterate over all contacts
            foreach (var result in this.SensorResults)
            {
                for (var i = 0; i < result.Contacts.Count; ++i)
                {
                    var normal = result.Normals[i];
                    
                    // Only process contacts with normals not perpendicular to our forward vector
                    var normDotForw = Math.Dot(normal, worldForward);
                    
                    if (Math.ApproximatelyEqual(normDotForw, 0.0, 0.0001))
                    {
                        continue;
                    }
                    
                    var contact = result.Contacts[i];
                    
                    // Project the contact onto the plane{ right, forward }
                    contact = Math.ProjectOnPlane(contact, this.Orientation.WorldUp);
                    
                    // Only process contacts inside of our cone
                    var contactDir = contact - this.Transform.WorldTranslation;
                    var forwardDistance = Math.Dot(contactDir, worldForward);
                    
                    // If (contact is behind cone OR out of the cone's distance)
                    if (forwardDistance < 0.0 || forwardDistance > this.ConeDistance)
                    {
                        continue;
                    }
                    
                    var contactNorm = Math.Normalize(contactDir);
                    var contactAngle = Math.SignedAngle(contactNorm, worldForward, worldUp);
                    
                    // If (contact is outside of our cone angle)
                    if (Math.Abs(contactAngle) > this.ConeAngleRad)
                    {
                        continue;
                    }
                    
                    // Determine what side of the vector this projected point is on
                    var positiveDir = contactAngle > 0.0;
                    
                    if (positiveDir)
                    {
                        // If (we've already processed a contact closer than this one)
                        if (forwardDistance > posClosestDistance)
                        {
                            continue;
                        }
                        
                        // Save the new closest distance, and new angle of correction
                        posClosestDistance = forwardDistance;
                        posAngleChange = this.ConeAngleRad - contactAngle;
                    }
                    else
                    {
                        // If (we've already processed a contact closer than this one)
                        if (forwardDistance > negClosestDistance)
                        {
                            continue;
                        }
                        
                        // Save the new closest distance, and new angle of correction
                        negClosestDistance = forwardDistance;
                        negAngleChange = -this.ConeAngleRad - contactAngle;
                    }
                }
            }
            
            if (this.LastYawRotation > 0.0)
            {
                yawAngleChange = posAngleChange;
            }
            else
            {
                yawAngleChange = negAngleChange;
            }
            
            if (yawAngleChange != 0.0)
            {
                // Apply our yaw rotation to the world forward
                worldForward = Math.RotateVector(worldForward, worldUp, yawAngleChange);
                rotated = true;
            }
            
            this.LastYawRotation = yawAngleChange;
        }
        
        // Solve for Pitch
        if (this.PitchRotation && this.SensorResults != null)
        {
            
        }
        
        // TODO: Determine if we need to move back
        
        // TODO: Determine if we need to flush contacts (Alow for sparse sensing)
        
        if (rotated)
        {
            this.AddLookDirection(worldForward);
        }
        
        this.SensorResults = null;
    }
    
    // Callback for sensor results
    function OnSensorEvent(event : SensorEvent)
    {
        // Store the results
        this.SensorResults = event.Results;
    }
    
    function DebugDrawCone(direction : Real3)
    {
        var cone = new DebugCone();
        
        cone.Position = this.Transform.WorldTranslation;
        cone.Direction = direction;
        cone.Length = this.ConeDistance;
        cone.Radius = Math.Tan(this.ConeAngleRad) * this.ConeDistance;
        
        DebugDraw.Add(cone);
    }
    
    function DebugDrawContacts()
    {
        if (this.SensorResults == null)
        {
            return;
        }
        
        foreach (var result in this.SensorResults)
        {
            foreach (var contact in result.Contacts)
            {
                var cube = new DebugObb();
                
                cube.Position = contact;
                cube.Extents = Real3(0.5);
                cube.Color = Real4(1.0, 0.0, 0.0, 1.0);
                
                DebugDraw.Add(cube);
            }
        }
    }
}
