// Component: Vision2D
// Brief: This component uses a spherical cast, dot product test, and a raycast test to check
// for objects within a specified viewing angle oriented to the object's world forward.
// the plane the vision check is performed on is based of the orientation component.
// This component can be configured to dispatch an event for each object detected. It can
// also be configured to have the vision check called manually as opposed to the default,
// OnLogicUpdate. The user also has the ability to defines properties of the types of objects
// they wish to detect using rigidbody flags and a collision filter to configure a cast filter.
// The vision check can be visualized by turning on debugdraw.

class Vision2D : ZilchComponent
{
    // This component requires the object to have an orientation component.
    [Dependency]
    var Orientation : Orientation = null;
    
    // Determines if this component is active
    [Property]
    var Active : Boolean = true;
    
    // Does the component send events for each seen object
    [Property]
    var SendsEvents : Boolean = false;
    
    // Should detected object events be sent up the hierarchy of this object?
    [Property]
    var DispatchUpHierarchy : Boolean = false;
    
    // Tells the component vision checks will be called manually
    [Property]
    var ManualQuery : Boolean = false;
    
    // Range of the vision cone
    [Property]
    var Range : Real = 10.0;
    
    // Width angle of the vision cone
    [Property]
    var ViewingConeAngle : Real = 150.0;
    
    // The maximum number of object that will be collect in the initial sphere cast
    [Property]
    var MaxDetectionCount : Integer = 100;
    
    // The collsion group to be used during the intial sphere cast
    [Property]
    var VisionCheckCollisionGroup : CollisionGroup = null;
    
    // Should children be excluded from the vision check
    [Property]
    var IgnoreChildren : Boolean = true;
    
    // Should static be excluded from the vision check
    [Property]
    var IgnoreStatic : Boolean = true;
    
    // Should children be excluded from the vision check
    [Property]
    var IgnoreGhost : Boolean = false;
    
    // Should this componet debug draw the vision check
    [Property]
    var EnableDebugDraw : Boolean = false;
        
    // The vision filter that will 
    var VisionFilter : CastFilter = null;
    
    // List of the objects detected in the most recent vision check
    var DetectedObjs : Array[Cog] = null;
    
    var ConeAngle : Real
    {
        get { return Math.ToRadians(this.ViewingConeAngle); }
        set { this.ViewingConeAngle = Math.ToDegrees(value); }
    }
    
    //Dot product limit for the vision cone angle
    var ConeAngleDotLimit : Real = 0.0;
    
    function Initialize(init : CogInitializer)
    {
        // Allocate the array to store sighted objects
        this.DetectedObjs  = new Array[Cog]();
        
        // Initialize the dot limit for later
        this.ConeAngleDotLimit = this.CalcAngleDot(this.ConeAngle/2.0);
        
        // Create the vision filter to be used in the intial sphere cast
        this.VisionFilter = this.Space.PhysicsSpace.CreateDefaultCastFilter();
        this.VisionFilter.IgnoreChildren = this.IgnoreChildren;
        this.VisionFilter.IgnoreStatic = this.IgnoreStatic;
        this.VisionFilter.IgnoreGhost = this.IgnoreGhost;
        
        // Dynamic and Kinematic object should never be ignored
        // Collision groups can be used to ignore specific types o objects
        this.VisionFilter.IgnoreDynamic = false;
        this.VisionFilter.IgnoreKinematic = false;
        
        // Define the types of objects we want to check for
        this.VisionFilter.CollisionGroup = this.VisionCheckCollisionGroup;
        
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    }


    function OnLogicUpdate(event : UpdateEvent)
    {
        // If the component is not active 
        if(!this.Active)
        {
            return;
        }
        
        // If the user wants to check vision manually let them
        if(!this.ManualQuery)
        {
            this.CheckVision();
        }
    }
    
    function CheckInVision(obj : Cog) : Boolean 
    {
        // Calculate the dot product of the direction to the obj and the world forward
        var objDir = Math.Normalize(obj.Transform.Translation - this.Owner.Transform.Translation);
        var objDot = Math.Dot(this.Orientation.WorldForward, objDir);
        
        // Use the calculate dot product to detect if the obj is within the range of the viewing cone
        if(this.ConeAngleDotLimit <= objDot)
        {
            // Cast a ray to the obj in the viewing cone to find if there is another object abstructing the view
            var castRay : Ray = Ray();
            castRay.Start = this.Owner.Transform.Translation;
            castRay.Direction = objDir;
            var result = this.Space.PhysicsSpace.CastRayFirst(castRay);
            
            // If the first object hit is the the object being checked against the view of the object is not obstructed
            if(result.ObjectHit == obj)
            {
                // add the object to the list of detected objects for this vision check
                return true;
            }
        }
        
        return false;
    }
    
    // Checks for objects within a specified vision cone and store te results in a member array
    function CheckVision() : Array[Cog]
    {
        // Perform the vision check
        this.GetVisibleObjectsInCone();
        
        // If the user wants, dispatch events notifying them of detected objects
        if(this.SendsEvents)
        {
            // Dispatch a notifacation event for each obj
            foreach(var obj in this.DetectedObjs)
            {
                var visionEvent : VisionEvent = new VisionEvent();
                visionEvent.Object = obj;
                
                // Does the user want the hierarchy to be notified
                if(this.DispatchUpHierarchy)
                {
                    this.Owner.DispatchUp("VisionEvent", visionEvent);
                }
                else
                {
                    this.Owner.DispatchEvent("VisionEvent", visionEvent);
                }
            }
        }
        
        // Should the vision check debug draw
        if(this.EnableDebugDraw)
        {
            this.DrawDebug();
        }
        
        // Return the list of detected objects encase the function is call manually
        return this.DetectedObjs;
    }
    
    // Return the object's that succeed in the vision test
    function GetVisibleObjectsInCone() : Array[Cog]
    {
        // Clear the existing list of detected objects
        this.DetectedObjs.Clear();
        
        // Cast a sphere to get all objects with in range of being in vision
        var results = this.Space.PhysicsSpace.CastSphereResults(this.Owner.Transform.Translation, this.Range, this.MaxDetectionCount, this.VisionFilter);
        foreach(var obj in results.All)
        {
            // Calculate the dot product of the direction to the obj and the world forward
            var objDir = Math.Normalize(obj.WorldPosition - this.Owner.Transform.Translation);
            var objDot = Math.Dot(this.Orientation.WorldForward, objDir);
            
            // Use the calculate dot product to detect if the obj is within the range of the viewing cone
            if(this.ConeAngleDotLimit <= objDot)
            {
                // Cast a ray to the obj in the viewing cone to find if there is another object abstructing the view
                var castRay : Ray = Ray();
                castRay.Start = this.Owner.Transform.Translation;
                castRay.Direction = objDir;
                var result = this.Space.PhysicsSpace.CastRayFirst(castRay);
                
                // If the first object hit is the the object being checked against the view of the object is not obstructed
                if(result.ObjectHit == obj.ObjectHit)
                {
                    // add the object to the list of detected objects for this vision check
                    this.DetectedObjs.Add(obj.ObjectHit);
                }
            }
        }
        
        // Return the list of detected objects encase the function is call manually
        return this.DetectedObjs;
    }
    
    // Performs the debug drawing of the vision check
    function DrawDebug()
    {
        // Draw the sphere that indicates the vision range
        var sphere = new DebugSphere();
        sphere.Position(this.Owner.Transform.Translation).Radius(this.Range).Float4Color(local Real4(1.0,1.0,1.0,0.1));
        sphere.Draw();
        
        // Draw the line that indicates the left edge of the viewing cone
        var leftAngle = this.Owner.Orientation.AbsoluteAngle + (this.ConeAngle/2.0);
        var leftDir = (this.Owner.Orientation.LocalForward * Math.Cos(leftAngle)) - (this.Owner.Orientation.LocalRight * Math.Sin(leftAngle));
        var line1 = new DebugLine();
        line1.Start(this.Owner.Transform.Translation).End(this.Owner.Transform.Translation + (leftDir * this.Range)).Float4Color(local Real4(1.0,0.0,0.0,1.0));
        line1.Draw();
        
        // Draw the line that indicates the right edge of the viewing cone
        var rightAngle = this.Owner.Orientation.AbsoluteAngle - (this.ConeAngle/2.0);
        Console.WriteLine("LocalRight: `this.Owner.Orientation.LocalRight`");
        var rightDir = (this.Owner.Orientation.LocalForward * Math.Cos(rightAngle)) - (this.Owner.Orientation.LocalRight * Math.Sin(rightAngle));
        var line2 = new DebugLine();
        line2.Start(this.Owner.Transform.Translation).End(this.Owner.Transform.Translation + (rightDir * this.Range)).Float4Color(local Real4(1.0,0.0,0.0,1.0));
        line2.Draw();
        
        // Draw the line that indicates the world forward
        var line3 = new DebugLine();
        line3.Start(this.Owner.Transform.Translation).End(this.Owner.Transform.Translation + (this.Owner.Orientation.WorldForward * this.Range * 0.5)).HeadSize(0.5).Float4Color(local Real4(0.0,0.0,1.0,1.0));
        line3.Draw();
        
        // Draw arrows to the detected objects within the viewing cone
        foreach(var obj in this.DetectedObjs)
        {
            var arrow = new DebugLine();
            arrow.Start(this.Owner.Transform.Translation).End(obj.Transform.Translation).HeadSize(0.5).Float4Color(local Real4(0.0,1.0,0.0,1.0));
            arrow.Draw();
        }
    }
    
    //Calculates the dot product between Real3(1.0,0.0,0.0) and the unit vector of the given angle
    function CalcAngleDot(angle : Real) : Real
    {
        var vec : Real3 = local Real3(Math.Cos(angle), Math.Sin(angle),0.0);
        return Math.Dot(Real3(1.0,0.0,0.0), vec);
    }
}

/// The event used to notify the object of a detected object
class VisionEvent : ZilchEvent
{
    var Object : Cog = null;
    constructor() : base()
    {
    }
}
