/************************************************************************************************************/
/* Copyright 2016 DigiPen, All Rights Reserved                                                              */
/* Last Update: 1/3/2016                                                                                    */
/* Author: Zero Engine Team                                                                                 */
/* Last updated by: Arend Danielek                                                                          */
/* Class: ViewportConfiguration                                                                             */
/* Brief: Creates, and configures viewport(s) spatial configuration on the screen based of player count.    */
/* Brief: This component uses a spherical cast, dot product test, and a raycast test to check               */
/* for objects within a specified viewing angle oriented to the object's world forward.                     */
/* the plane the vision check is performed on is based of the orientation component.                        */
/* This component can be configured to dispatch an event for each object detected. It can                   */
/* also be configured to have the vision check called manually as opposed to the default,                   */
/* OnLogicUpdate. The user also has the ability to defines properties of the types of objects               */
/* they wish to detect using rigidbody flags and a collision filter to configure a cast filter.             */
/* The vision check can be visualized by turning on debugdraw.                                              */
/************************************************************************************************************/

class Vision2D : ZilchComponent
{
  // This component requires the object to have an orientation component.
  [Dependency]
  var Orientation : Orientation = null;
  
  // Determines if this component is active
  [Property]
  var Active : Boolean = true;
  
  // Does the component send events for each seen object
  [Property]
  var SendsEvents : Boolean = false;
  
  // Should detected object events be sent up the hierarchy of this object?
  [Property]
  var DispatchUpHierarchy : Boolean = false;
  
  // Tells the component vision checks will be called manually
  [Property]
  var ManualQuery : Boolean = false;
  
  // Range of the vision cone
  [Property]
  var Range : Real = 10.0;
  
  // Width angle of the vision cone
  [Property]
  var ViewingConeAngle : Real = 150.0;
  
  // The maximum number of object that will be collect in the initial sphere cast
  [Property]
  var MaxDetectionCount : Integer = 100;
  
  // The collsion group to be used during the intial sphere cast
  [Property]
  var VisionCheckCollisionGroup : CollisionGroup = null;
  
  // Should children be excluded from the vision check
  [Property]
  var IgnoreChildren : Boolean = true;
  
  // Should static be excluded from the vision check
  [Property]
  var IgnoreStatic : Boolean = true;
  
  // Should children be excluded from the vision check
  [Property]
  var IgnoreGhost : Boolean = false;
  
  // Should this componet debug draw the vision check
  [Property]
  var EnableDebugDraw : Boolean = false;
      
  // The vision filter that will 
  var VisionFilter : CastFilter = null;
  
  // List of the objects detected in the most recent vision check
  var DetectedObjs : Array[Cog] = null;
  
  var ConeAngle : Real
  {
    get { return Math.ToRadians(this.ViewingConeAngle); }
    set { this.ViewingConeAngle = Math.ToDegrees(value); }
  }
  
  //Dot product limit for the vision cone angle
  var ConeAngleDotLimit : Real = 0.0;
  
  function Initialize(init : CogInitializer)
  {
    // Allocate the array to store sighted objects
    this.DetectedObjs  = Array[Cog]();
    
    // Initialize the dot limit for later
    this.ConeAngleDotLimit = this.CalcAngleDot(this.ConeAngle/2.0);
    
    // Create the vision filter to be used in the intial sphere cast
    this.VisionFilter = new CastFilter();
    this.VisionFilter.IgnoreChildren = this.IgnoreChildren;
    this.VisionFilter.IgnoreStatic = this.IgnoreStatic;
    this.VisionFilter.IgnoreGhost = this.IgnoreGhost;
    
    // Dynamic and Kinematic object should never be ignored
    // Collision groups can be used to ignore specific types o objects
    this.VisionFilter.IgnoreDynamic = false;
    this.VisionFilter.IgnoreKinematic = false;
    
    // Define the types of objects we want to check for
    this.VisionFilter.CollisionGroup = this.VisionCheckCollisionGroup;
    
    Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
  }


  function OnLogicUpdate(event : UpdateEvent)
  {
    // If the component is not active 
    if(!this.Active)
    {
      return;
    }
    
    // If the user wants to check vision manually let them
    if(!this.ManualQuery)
    {
      this.CheckVision();
    }
  }
  
  function CheckInVision(obj : Cog) : Boolean 
  {
    // Calculate the dot product of the direction to the obj and the world forward
    var objDir = Math.Normalize(obj.Transform.Translation - this.Owner.Transform.Translation);
    var objDot = Math.Dot(this.Orientation.WorldForward, objDir);
    
    // Use the calculate dot product to detect if the obj is within the range of the viewing cone
    if(this.ConeAngleDotLimit <= objDot)
    {
      // Cast a ray to the obj in the viewing cone to find if there is another object abstructing the view
      var castRay : Ray = Ray();
      castRay.Start = this.Owner.Transform.Translation;
      castRay.Direction = objDir;
      var result = this.Space.PhysicsSpace.CastRayFirst(castRay);
      
      // If the first object hit is the the object being checked against the view of the object is not obstructed
      if(result.ObjectHit == obj)
      {
        // add the object to the list of detected objects for this vision check
        return true;
      }
    }
    
    return false;
  }
  
  // Checks for objects within a specified vision cone and store te results in a member array
  function CheckVision() : Array[Cog]
  {
    // Perform the vision check
    this.GetVisibleObjectsInCone();
    
    // If the user wants, dispatch events notifying them of detected objects
    if(this.SendsEvents)
    {
      // Dispatch a notifacation event for each obj
      foreach(var obj in this.DetectedObjs)
      {
        var visionEvent : VisionEvent = VisionEvent();
        visionEvent.Object = obj;
        
        // Does the user want the hierarchy to be notified
        if(this.DispatchUpHierarchy)
        {
          this.Owner.DispatchUp(Events.VisionEvent, visionEvent);
        }
        else
        {
          this.Owner.DispatchEvent(Events.VisionEvent, visionEvent);
        }
      }
    }
    
    // Should the vision check debug draw
    if(this.EnableDebugDraw)
    {
      this.DrawDebug();
    }
    
    // Return the list of detected objects encase the function is call manually
    return this.DetectedObjs;
  }
  
  // Return the object's that succeed in the vision test
  function GetVisibleObjectsInCone() : Array[Cog]
  {
    // Clear the existing list of detected objects
    this.DetectedObjs.Clear();
    
    // Cast a sphere to get all objects with in range of being in vision
    var sphere = Sphere();
    sphere.Center = this.Owner.Transform.Translation;
    sphere.Radius = this.Range;
    
    var results = this.Space.PhysicsSpace.CastSphere(sphere, this.MaxDetectionCount, this.VisionFilter);
    foreach(var obj in results.All)
    {
      // Calculate the dot product of the direction to the obj and the world forward
      var objDir = Math.Normalize(obj.WorldPosition - this.Owner.Transform.Translation);
      var objDot = Math.Dot(this.Orientation.WorldForward, objDir);
      
      // Use the calculate dot product to detect if the obj is within the range of the viewing cone
      if(this.ConeAngleDotLimit <= objDot)
      {
        // Cast a ray to the obj in the viewing cone to find if there is another object abstructing the view
        var castRay : Ray = Ray();
        castRay.Start = this.Owner.Transform.Translation;
        castRay.Direction = objDir;
        var result = this.Space.PhysicsSpace.CastRayFirst(castRay);
        
        // If the first object hit is the the object being checked against the view of the object is not obstructed
        if(result.ObjectHit == obj.ObjectHit)
        {
          // add the object to the list of detected objects for this vision check
          this.DetectedObjs.Add(obj.ObjectHit);
        }
      }
    }
    
    // Return the list of detected objects encase the function is call manually
    return this.DetectedObjs;
  }
  
  // Performs the debug drawing of the vision check
  function DrawDebug()
  {
    // Draw the sphere that indicates the vision range
    var position = this.Owner.Transform.Translation;
    var radius = this.Range;
    var sphere = DebugSphere(position, radius);
    
    sphere.Color = Real4(1.0,1.0,1.0,0.1);
    DebugDraw.Add(sphere);
    
    // Draw the line that indicates the left edge of the viewing cone
    var leftAngle = this.Owner.Orientation.AbsoluteAngle + (this.ConeAngle/2.0);
    var leftDir = (this.Owner.Orientation.LocalForward * Math.Cos(leftAngle)) - (this.Owner.Orientation.LocalRight * Math.Sin(leftAngle));
    var start1 = this.Owner.Transform.Translation;
    var end1 = this.Owner.Transform.Translation + (leftDir * this.Range);
    var line1 = DebugLine(start1, end1);
    
    line1.Color = Real4(1.0,0.0,0.0,1.0);
    DebugDraw.Add(line1);
    
    // Draw the line that indicates the right edge of the viewing cone
    var rightAngle = this.Owner.Orientation.AbsoluteAngle - (this.ConeAngle/2.0);
    var rightDir = (this.Owner.Orientation.LocalForward * Math.Cos(rightAngle)) - (this.Owner.Orientation.LocalRight * Math.Sin(rightAngle));
    var start2 = this.Owner.Transform.Translation;
    var end2 = this.Owner.Transform.Translation + (rightDir * this.Range);
    var line2 = DebugLine(start2, end2);
    
    line2.Color = Real4(1.0,0.0,0.0,1.0);
    DebugDraw.Add(line2);
    
    // Draw the line that indicates the world forward
    var start3 = this.Owner.Transform.Translation;
    var end3 = this.Owner.Transform.Translation + (this.Owner.Orientation.WorldForward * this.Range * 0.5);
    var line3 = DebugLine(start3, end3);
    
    line3.HeadSize = 0.5;
    line3.Color = Real4(0.0,0.0,1.0,1.0);
    DebugDraw.Add(line3);
    
    // Draw arrows to the detected objects within the viewing cone
    foreach(var obj in this.DetectedObjs)
    {
      var start = this.Owner.Transform.Translation;
      var end = obj.Transform.Translation;
      var arrow = DebugLine(start, end);
      
      arrow.HeadSize = 0.5;
      arrow.Color = Real4(0.0,1.0,0.0,1.0);
      DebugDraw.Add(arrow);
    }
  }
  
  //Calculates the dot product between Real3(1.0,0.0,0.0) and the unit vector of the given angle
  function CalcAngleDot(angle : Real) : Real
  {
    var vec : Real3 = Real3(Math.Cos(angle), Math.Sin(angle),0.0);
    return Math.Dot(Real3(1.0,0.0,0.0), vec);
  }
}

/// The event used to notify the object of a detected object
class VisionEvent : ZilchEvent
{
    sends VisionEvent : VisionEvent;
    var Object : Cog;
}
